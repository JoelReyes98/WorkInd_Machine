import { __awaiter } from "tslib";
import * as JSZip from 'jszip';
import { EventEmitter, Injectable, Output } from '@angular/core';
import { ExcelElementsFactory } from './excel-elements-factory';
import { ExcelFolderTypes } from './excel-enums';
import { IgxBaseExporter } from '../exporter-common/base-export-service';
import { ExportUtilities } from '../exporter-common/export-utilities';
import { WorksheetData } from './worksheet-data';
import { WorksheetFile } from './excel-files';
/**
 * **Ignite UI for Angular Excel Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
 *
 * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
 * (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private excelExportService: IgxExcelExporterService) {
 * }
 *
 * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
 * ```
 */
export class IgxExcelExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxExcelExporterService
         */
        this.onExportEnded = new EventEmitter();
    }
    static populateFolderAsync(folder, zip, worksheetData) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const childFolder of folder.childFolders(worksheetData)) {
                const folderInstance = ExcelElementsFactory.getExcelFolder(childFolder);
                const zipFolder = zip.folder(folderInstance.folderName);
                yield IgxExcelExporterService.populateFolderAsync(folderInstance, zipFolder, worksheetData);
            }
            for (const childFile of folder.childFiles(worksheetData)) {
                const fileInstance = ExcelElementsFactory.getExcelFile(childFile);
                if (fileInstance instanceof WorksheetFile) {
                    yield fileInstance.writeElementAsync(zip, worksheetData);
                }
                else {
                    fileInstance.writeElement(zip, worksheetData);
                }
            }
        });
    }
    exportDataImplementation(data, options) {
        if (this._isTreeGrid) {
            let maxLevel = 0;
            data.forEach((r) => {
                maxLevel = Math.max(maxLevel, r.originalRowData.level);
            });
            if (maxLevel > 7) {
                throw Error('Can create an outline of up to eight levels!');
            }
        }
        const worksheetData = new WorksheetData(data, this.columnWidthList, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
        this._xlsx = new JSZip();
        const rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
        IgxExcelExporterService.populateFolderAsync(rootFolder, this._xlsx, worksheetData)
            .then(() => {
            this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then((result) => {
                this.saveFile(result, options.fileName);
                this.onExportEnded.emit({ xlsx: this._xlsx });
            });
        });
    }
    saveFile(data, fileName) {
        const blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
        });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
IgxExcelExporterService.decorators = [
    { type: Injectable }
];
IgxExcelExporterService.propDecorators = {
    onExportEnded: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWwtZXhwb3J0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc2VydmljZXMvZXhjZWwvZXhjZWwtZXhwb3J0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBRS9CLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHakQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN0RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFakQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQU05Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFFSCxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsZUFBZTtJQUQ1RDs7UUFNSTs7Ozs7Ozs7V0FRRztRQUVJLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQThCLENBQUM7SUFxRDFFLENBQUM7SUFuRFcsTUFBTSxDQUFPLG1CQUFtQixDQUFDLE1BQW9CLEVBQUUsR0FBVSxFQUFFLGFBQTRCOztZQUNuRyxLQUFLLE1BQU0sV0FBVyxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQzFELE1BQU0sY0FBYyxHQUFHLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDeEUsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ3hELE1BQU0sdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsY0FBYyxFQUFFLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FBQzthQUMvRjtZQUVELEtBQUssTUFBTSxTQUFTLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDdEQsTUFBTSxZQUFZLEdBQUcsb0JBQW9CLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUNsRSxJQUFJLFlBQVksWUFBWSxhQUFhLEVBQUU7b0JBQ3ZDLE1BQU8sWUFBOEIsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLENBQUM7aUJBQy9FO3FCQUFNO29CQUNILFlBQVksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2lCQUNqRDthQUNKO1FBQ0wsQ0FBQztLQUFBO0lBRVMsd0JBQXdCLENBQUMsSUFBVyxFQUFFLE9BQWdDO1FBQzVFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNsQixJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDakIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNmLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNELENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxRQUFRLEdBQUcsQ0FBQyxFQUFFO2dCQUNkLE1BQU0sS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7YUFDL0Q7U0FDSjtRQUVELE1BQU0sYUFBYSxHQUNmLElBQUksYUFBYSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFeEgsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBRXpCLE1BQU0sVUFBVSxHQUFHLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUV6Rix1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUM7YUFDakYsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNQLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLHVCQUF1QixDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO2dCQUMxRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3hDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ2xELENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU8sUUFBUSxDQUFDLElBQVksRUFBRSxRQUFnQjtRQUMzQyxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3JFLElBQUksRUFBRSxFQUFFO1NBQ1gsQ0FBQyxDQUFDO1FBRUgsZUFBZSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDbkQsQ0FBQzs7QUFqRWMsbUNBQVcsR0FBRyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBMkMsQ0FBQzs7WUFIcEgsVUFBVTs7OzRCQWVOLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBKU1ppcCBmcm9tICdqc3ppcCc7XG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFeGNlbEVsZW1lbnRzRmFjdG9yeSB9IGZyb20gJy4vZXhjZWwtZWxlbWVudHMtZmFjdG9yeSc7XG5pbXBvcnQgeyBFeGNlbEZvbGRlclR5cGVzIH0gZnJvbSAnLi9leGNlbC1lbnVtcyc7XG5pbXBvcnQgeyBJZ3hFeGNlbEV4cG9ydGVyT3B0aW9ucyB9IGZyb20gJy4vZXhjZWwtZXhwb3J0ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJRXhjZWxGb2xkZXIgfSBmcm9tICcuL2V4Y2VsLWludGVyZmFjZXMnO1xuaW1wb3J0IHsgSWd4QmFzZUV4cG9ydGVyIH0gZnJvbSAnLi4vZXhwb3J0ZXItY29tbW9uL2Jhc2UtZXhwb3J0LXNlcnZpY2UnO1xuaW1wb3J0IHsgRXhwb3J0VXRpbGl0aWVzIH0gZnJvbSAnLi4vZXhwb3J0ZXItY29tbW9uL2V4cG9ydC11dGlsaXRpZXMnO1xuaW1wb3J0IHsgV29ya3NoZWV0RGF0YSB9IGZyb20gJy4vd29ya3NoZWV0LWRhdGEnO1xuaW1wb3J0IHsgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IFdvcmtzaGVldEZpbGUgfSBmcm9tICcuL2V4Y2VsLWZpbGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBJRXhjZWxFeHBvcnRFbmRlZEV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICB4bHN4PzogSlNaaXA7XG59XG5cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgRXhjZWwgRXhwb3J0ZXIgU2VydmljZSoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9leHBvcnRlcl9leGNlbC5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgRXhjZWwgRXhwb3J0ZXIgc2VydmljZSBjYW4gZXhwb3J0IGRhdGEgaW4gTWljcm9zb2Z0wq4gRXhjZWzCriBmb3JtYXQgZnJvbSBib3RoIHJhdyBkYXRhXG4gKiAoYXJyYXkpIG9yIGZyb20gYW4gYElneEdyaWRgLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBwdWJsaWMgbG9jYWxEYXRhID0gW1xuICogICB7IE5hbWU6IFwiRXJpYyBSaWRsZXlcIiwgQWdlOiBcIjI2XCIgfSxcbiAqICAgeyBOYW1lOiBcIkFsYW5pcyBCcm9va1wiLCBBZ2U6IFwiMjJcIiB9LFxuICogICB7IE5hbWU6IFwiSm9uYXRoYW4gTW9ycmlzXCIsIEFnZTogXCIyM1wiIH1cbiAqIF07XG4gKlxuICogY29uc3RydWN0b3IocHJpdmF0ZSBleGNlbEV4cG9ydFNlcnZpY2U6IElneEV4Y2VsRXhwb3J0ZXJTZXJ2aWNlKSB7XG4gKiB9XG4gKlxuICogdGhpcy5leGNlbEV4cG9ydFNlcnZpY2UuZXhwb3J0RGF0YSh0aGlzLmxvY2FsRGF0YSwgbmV3IElneEV4Y2VsRXhwb3J0ZXJPcHRpb25zKFwiRmlsZU5hbWVcIikpO1xuICogYGBgXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hFeGNlbEV4cG9ydGVyU2VydmljZSBleHRlbmRzIElneEJhc2VFeHBvcnRlciB7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBaSVBfT1BUSU9OUyA9IHsgY29tcHJlc3Npb246ICdERUZMQVRFJywgdHlwZTogJ2Jhc2U2NCcgfSBhcyBKU1ppcC5KU1ppcEdlbmVyYXRvck9wdGlvbnM8J2Jhc2U2NCc+O1xuICAgIHByaXZhdGUgX3hsc3g6IEpTWmlwO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIGV4cG9ydCBwcm9jZXNzIGZpbmlzaGVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmV4cG9ydGVyU2VydmljZS5vbkV4cG9ydEVuZGVkLnN1YnNjcmliZSgoYXJnczogSUV4Y2VsRXhwb3J0RW5kZWRFdmVudEFyZ3MpID0+IHtcbiAgICAgKiAvLyBwdXQgZXZlbnQgaGFuZGxlciBjb2RlIGhlcmVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RXhjZWxFeHBvcnRlclNlcnZpY2VcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25FeHBvcnRFbmRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUV4Y2VsRXhwb3J0RW5kZWRFdmVudEFyZ3M+KCk7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBwb3B1bGF0ZUZvbGRlckFzeW5jKGZvbGRlcjogSUV4Y2VsRm9sZGVyLCB6aXA6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRGb2xkZXIgb2YgZm9sZGVyLmNoaWxkRm9sZGVycyh3b3Jrc2hlZXREYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVySW5zdGFuY2UgPSBFeGNlbEVsZW1lbnRzRmFjdG9yeS5nZXRFeGNlbEZvbGRlcihjaGlsZEZvbGRlcik7XG4gICAgICAgICAgICBjb25zdCB6aXBGb2xkZXIgPSB6aXAuZm9sZGVyKGZvbGRlckluc3RhbmNlLmZvbGRlck5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgSWd4RXhjZWxFeHBvcnRlclNlcnZpY2UucG9wdWxhdGVGb2xkZXJBc3luYyhmb2xkZXJJbnN0YW5jZSwgemlwRm9sZGVyLCB3b3Jrc2hlZXREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRGaWxlIG9mIGZvbGRlci5jaGlsZEZpbGVzKHdvcmtzaGVldERhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlSW5zdGFuY2UgPSBFeGNlbEVsZW1lbnRzRmFjdG9yeS5nZXRFeGNlbEZpbGUoY2hpbGRGaWxlKTtcbiAgICAgICAgICAgIGlmIChmaWxlSW5zdGFuY2UgaW5zdGFuY2VvZiBXb3Jrc2hlZXRGaWxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKGZpbGVJbnN0YW5jZSBhcyBXb3Jrc2hlZXRGaWxlKS53cml0ZUVsZW1lbnRBc3luYyh6aXAsIHdvcmtzaGVldERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlSW5zdGFuY2Uud3JpdGVFbGVtZW50KHppcCwgd29ya3NoZWV0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZXhwb3J0RGF0YUltcGxlbWVudGF0aW9uKGRhdGE6IGFueVtdLCBvcHRpb25zOiBJZ3hFeGNlbEV4cG9ydGVyT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXNUcmVlR3JpZCkge1xuICAgICAgICAgICAgbGV0IG1heExldmVsID0gMDtcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICAgICAgICAgIG1heExldmVsID0gTWF0aC5tYXgobWF4TGV2ZWwsIHIub3JpZ2luYWxSb3dEYXRhLmxldmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1heExldmVsID4gNykge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW4gY3JlYXRlIGFuIG91dGxpbmUgb2YgdXAgdG8gZWlnaHQgbGV2ZWxzIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya3NoZWV0RGF0YSA9XG4gICAgICAgICAgICBuZXcgV29ya3NoZWV0RGF0YShkYXRhLCB0aGlzLmNvbHVtbldpZHRoTGlzdCwgb3B0aW9ucywgdGhpcy5faW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4sIHRoaXMuX3NvcnQsIHRoaXMuX2lzVHJlZUdyaWQpO1xuXG4gICAgICAgIHRoaXMuX3hsc3ggPSBuZXcgSlNaaXAoKTtcblxuICAgICAgICBjb25zdCByb290Rm9sZGVyID0gRXhjZWxFbGVtZW50c0ZhY3RvcnkuZ2V0RXhjZWxGb2xkZXIoRXhjZWxGb2xkZXJUeXBlcy5Sb290RXhjZWxGb2xkZXIpO1xuXG4gICAgICAgIElneEV4Y2VsRXhwb3J0ZXJTZXJ2aWNlLnBvcHVsYXRlRm9sZGVyQXN5bmMocm9vdEZvbGRlciwgdGhpcy5feGxzeCwgd29ya3NoZWV0RGF0YSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5feGxzeC5nZW5lcmF0ZUFzeW5jKElneEV4Y2VsRXhwb3J0ZXJTZXJ2aWNlLlpJUF9PUFRJT05TKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVGaWxlKHJlc3VsdCwgb3B0aW9ucy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV4cG9ydEVuZGVkLmVtaXQoeyB4bHN4OiB0aGlzLl94bHN4IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2F2ZUZpbGUoZGF0YTogc3RyaW5nLCBmaWxlTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbRXhwb3J0VXRpbGl0aWVzLnN0cmluZ1RvQXJyYXlCdWZmZXIoYXRvYihkYXRhKSldLCB7XG4gICAgICAgICAgICB0eXBlOiAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICBFeHBvcnRVdGlsaXRpZXMuc2F2ZUJsb2JUb0ZpbGUoYmxvYiwgZmlsZU5hbWUpO1xuICAgIH1cbn1cbiJdfQ==