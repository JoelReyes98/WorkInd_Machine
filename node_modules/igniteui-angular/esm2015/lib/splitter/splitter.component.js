import { Component, Input, ContentChildren, HostBinding, Inject, ElementRef } from '@angular/core';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
import { DOCUMENT } from '@angular/common';
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
import * as ɵngcc0 from '@angular/core';

function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-splitter-bar", 2);
    ɵngcc0.ɵɵlistener("moveStart", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moveStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onMoveStart($event); })("moving", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moving_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.onMoving($event); })("movingEnd", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_movingEnd_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.onMoveEnd($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    const pane_r1 = ctx_r9.$implicit;
    const index_r3 = ctx_r9.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("order", pane_r1.order + 1)("type", ctx_r4.type)("pane", pane_r1)("siblings", ctx_r4.getPaneSiblingsByOrder(pane_r1.order + 1, index_r3));
} }
function IgxSplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template, 1, 4, "igx-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r2 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r2);
} }
const _c0 = [[["igx-splitter-pane"]]];
const _c1 = ["igx-splitter-pane"];
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        this._type = SplitterType.Horizontal;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the splitter orientation.
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
    }
    onMoveEnd(delta) {
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
}
IgxSplitterComponent.ɵfac = function IgxSplitterComponent_Factory(t) { return new (t || IgxSplitterComponent)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSplitterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitterComponent, selectors: [["igx-splitter"]], contentQueries: function IgxSplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSplitterPaneComponent, false, IgxSplitterPaneComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 6, hostBindings: function IgxSplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("overflow", ctx.overflow)("display", ctx.display)("flex-direction", ctx.direction);
    } }, inputs: { type: "type" }, ngContentSelectors: _c1, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving", "movingEnd", 4, "ngIf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving", "movingEnd"]], template: function IgxSplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, encapsulation: 2 });
IgxSplitterComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
IgxSplitterComponent.propDecorators = {
    type: [{ type: Input }],
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ElementRef }]; }, { overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], type: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['style.flex-direction']
        }], panes: [{
            type: ContentChildren,
            args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3BsaXR0ZXIvc3BsaXR0ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWEsS0FBSyxFQUFFLGVBQWUsRUFBb0IsV0FBVyxFQUF3QixNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RKLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ25GLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUzQztBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDSCxNQUFNLENBQU4sSUFBWSxZQUdYO0FBSEQsV0FBWSxZQUFZO0FBQ3ZCLElBQUcsMkRBQVUsQ0FBQTtBQUFDLElBQ1gsdURBQVEsQ0FBQTtBQUNaLENBQUMsRUFIVyxZQUFZLEtBQVosWUFBWSxRQUd2QjtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFLSCxNQUFNLE9BQU8sb0JBQW9CO0FBQUcsSUFHaEMsWUFBcUMsUUFBUSxFQUFVLFVBQXNCO0FBQUksUUFBNUMsYUFBUSxHQUFSLFFBQVEsQ0FBQTtBQUFDLFFBQVMsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDLFFBRnRFLFVBQUssR0FBaUIsWUFBWSxDQUFDLFVBQVUsQ0FBQztBQUMxRCxRQXdDSTtBQUNKO0FBQ0k7QUFFSixXQURPO0FBQ1AsUUFDVyxhQUFRLEdBQUcsUUFBUSxDQUFDO0FBQy9CLFFBQ0k7QUFDSjtBQUNJO0FBRUosV0FETztBQUNQLFFBQ1csWUFB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QztBQUE4Qyw0Q0FHbkMsTUFBTSxTQUFDLFFBQVE7QUFBUyxZQTVDMkUsVUFBVTtBQUFHO0FBQUc7QUFDL0csbUJBbURoQixLQUFLO0FBQ1Isb0JBa0JHLGVBQWUsU0FBQyx3QkFBd0IsRUFBRSxFQUFFLElBQUksRUFBRSx3QkFBd0IsRUFBRTtBQUM1RSx3QkFNQSxXQUFXLFNBQUMsc0JBQXNCO0FBQ2xDLHVCQVFBLFdBQVcsU0FBQyxnQkFBZ0I7QUFDNUIsc0JBTUEsV0FBVyxTQUFDLGVBQWU7QUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBRdWVyeUxpc3QsIElucHV0LCBDb250ZW50Q2hpbGRyZW4sIEFmdGVyQ29udGVudEluaXQsIEhvc3RCaW5kaW5nLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5qZWN0LCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQgfSBmcm9tICcuL3NwbGl0dGVyLXBhbmUvc3BsaXR0ZXItcGFuZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIHRoYXQgZGVmaW5lcyB0aGUgYFNwbGl0dGVyQ29tcG9uZW50YCBwYW5lcyBvcmllbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGVudW0gU3BsaXR0ZXJUeXBlIHtcbiAgICBIb3Jpem9udGFsLFxuICAgIFZlcnRpY2FsXG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBmcmFtZXdvcmsgZm9yIGEgc2ltcGxlIGxheW91dCwgc3BsaXR0aW5nIHRoZSB2aWV3IGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gKiBpbnRvIG11bHRpcGxlIHNtYWxsZXIgcmVzaXphYmxlIGFuZCBjb2xsYXBzaWJsZSBhcmVhcy5cbiAqIEBpZ3hNb2R1bGUgSWd4U3BsaXR0ZXJNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IExheW91dHNcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LXNwbGl0dGVyLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIHNwbGl0dGVyIHBhbmVzIGxheW91dFxuICpcbiAqIEBpZ3hHcm91cCBwcmVzZW50YXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zcGxpdHRlcj5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgPGlneC1zcGxpdHRlci1wYW5lPlxuICogICAgICAuLi5cbiAqICA8L2lneC1zcGxpdHRlci1wYW5lPlxuICogPC9pZ3gtc3BsaXR0ZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3BsaXR0ZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4U3BsaXR0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF90eXBlOiBTcGxpdHRlclR5cGUgPSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbDtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoRE9DVU1FTlQpIHB1YmxpYyBkb2N1bWVudCwgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc3BsaXR0ZXIgb3JpZW50YXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciBbdHlwZV09XCJ0eXBlXCI+Li4uPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMucGFuZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHR5cGUgaXMgY2hhbmdlZCBydW50aW1lLCBzaG91bGQgcmVzZXQgc2l6ZXMuXG4gICAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goeCA9PiB4LnNpemUgPSAnYXV0bycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBzcGxpdHRlciBwYW5lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwYW5lcyA9IHRoaXMuc3BsaXR0ZXIucGFuZXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQsIHsgcmVhZDogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0pXG4gICAgcHVibGljIHBhbmVzITogUXVlcnlMaXN0PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMgdGhlIGBmbGV4LWRpcmVjdGlvbmAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYFNwbGl0dGVyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXgtZGlyZWN0aW9uJylcbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdyb3cnIDogJ2NvbHVtbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzL1NldHMgdGhlIGBvdmVyZmxvd2AgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpXG4gICAgcHVibGljIG92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFNldHMvR2V0cyB0aGUgYGRpc3BsYXlgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHNwbGl0dGVyLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZGlzcGxheScpXG4gICAgcHVibGljIGRpc3BsYXkgPSAnZmxleCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEEgZmllbGQgdGhhdCBob2xkcyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBtYWluIGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgc3BsaXR0ZXIgYmFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbFBhbmVTaXplITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgc2libGluZyBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgZ3JpcHBlci5cbiAgICAgKiBAbWVtYmVyb2YgU3BsaXR0ZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxTaWJsaW5nU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhlIG1haW4gcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYW5lITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNpYmxpbmchOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2gocGFuZSA9PiBwYW5lLm93bmVyID0gdGhpcyk7XG4gICAgICAgIHRoaXMuYXNzaWduRmxleE9yZGVyKCk7XG4gICAgICAgIHRoaXMucGFuZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHBhbmUgPT4gcGFuZS5vd25lciA9IHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hc3NpZ25GbGV4T3JkZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyAgaW5pdGlhbGl6YXRpb24gbG9naWMgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHNwbGl0dGVyIGJhciBiZXR3ZWVuIGVhY2ggcGFpciBvZiBwYW5lcy5cbiAgICAgKiBAcGFyYW0gcGFuZSAtIHRoZSBtYWluIHBhbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgZHJhZ2dlZCBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92ZVN0YXJ0KHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICB0aGlzLnBhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLnNpYmxpbmcgPSBwYW5lc1twYW5lcy5pbmRleE9mKHRoaXMucGFuZSkgKyAxXTtcblxuICAgICAgICBjb25zdCBwYW5lUmVjdCA9IHRoaXMucGFuZS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxQYW5lU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBwYW5lUmVjdC53aWR0aCA6IHBhbmVSZWN0LmhlaWdodDtcblxuICAgICAgICBjb25zdCBzaWJsaW5nUmVjdCA9IHRoaXMuc2libGluZy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBzaWJsaW5nUmVjdC53aWR0aCA6IHNpYmxpbmdSZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGNhbGN1bGF0aW9ucyBjb25jZXJuaW5nIHRoZSBzaXplcyBvZiBlYWNoIHBhaXIgb2YgcGFuZXMgd2hlbiB0aGUgYmFyIGJldHdlZW4gdGhlbSBpcyBkcmFnZ2VkLlxuICAgICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkaWZmZXJlbmNlIGFsb25nIHRoZSBYIChvciBZKSBheGlzIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIHRoZSBjdXJyZW50IHBvaW50IHdoZW4gZHJhZ2dpbmcgdGhlIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZpbmcoZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBtaW4gPSBwYXJzZUludCh0aGlzLnBhbmUubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcnNlSW50KHRoaXMucGFuZS5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcbiAgICAgICAgY29uc3QgbWluU2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4U2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcblxuICAgICAgICBjb25zdCBwYW5lU2l6ZSA9IHRoaXMuaW5pdGlhbFBhbmVTaXplIC0gZGVsdGE7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdTaXplID0gdGhpcy5pbml0aWFsU2libGluZ1NpemUgKyBkZWx0YTtcbiAgICAgICAgaWYgKHBhbmVTaXplIDwgbWluIHx8IHBhbmVTaXplID4gbWF4IHx8IHNpYmxpbmdTaXplIDwgbWluU2libGluZyB8fCBzaWJsaW5nU2l6ZSA+IG1heFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhbmUuZHJhZ1NpemUgPSBwYW5lU2l6ZSArICdweCc7XG4gICAgICAgIHRoaXMuc2libGluZy5kcmFnU2l6ZSA9IHNpYmxpbmdTaXplICsgJ3B4JztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25Nb3ZlRW5kKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcGFuZVNpemUgPSB0aGlzLmluaXRpYWxQYW5lU2l6ZSAtIGRlbHRhO1xuICAgICAgICBjb25zdCBzaWJsaW5nU2l6ZSA9IHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplICsgZGVsdGE7XG4gICAgICAgIGlmICh0aGlzLnBhbmUuaXNQZXJjZW50YWdlU2l6ZSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlICUgcmVzaXplc1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy5nZXRUb3RhbFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRQYW5lU2l6ZSA9IChwYW5lU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDA7XG4gICAgICAgICAgICB0aGlzLnBhbmUuc2l6ZSA9IHBlcmNlbnRQYW5lU2l6ZSArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHB4IHJlc2l6ZVxuICAgICAgICAgICAgdGhpcy5wYW5lLnNpemUgPSBwYW5lU2l6ZSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaWJsaW5nLmlzUGVyY2VudGFnZVNpemUpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSAlIHJlc2l6ZXNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMuZ2V0VG90YWxTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50U2libGluZ1BhbmVTaXplID0gIChzaWJsaW5nU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDA7XG4gICAgICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHBlcmNlbnRTaWJsaW5nUGFuZVNpemUgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBweCByZXNpemVcbiAgICAgICAgICAgIHRoaXMuc2libGluZy5zaXplID0gc2libGluZ1NpemUgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFuZS5kcmFnU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2libGluZy5kcmFnU2l6ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb3RhbFNpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykgOiBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG90YWxTaXplKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyB0aGUgb3JkZXIgb2YgZWFjaCBwYW5lLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXNzaWduRmxleE9yZGVyKCkge1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBwYW5lLm9yZGVyID0gaztcbiAgICAgICAgICAgIGsgKz0gMjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldFBhbmVTaWJsaW5nc0J5T3JkZXIob3JkZXI6IG51bWJlciwgYmFySW5kZXg6IG51bWJlcik6IEFycmF5PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD4ge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBwcmV2UGFuZSA9IHBhbmVzW29yZGVyIC0gYmFySW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dFBhbmUgPSBwYW5lc1tvcmRlciAtIGJhckluZGV4XTtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbcHJldlBhbmUsIG5leHRQYW5lXTtcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgIH1cbn1cbiJdfQ==