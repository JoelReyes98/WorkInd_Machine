import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Observable } from 'rxjs';
import ResizeObserver from 'resize-observer-polyfill';
import { setImmediate } from './setImmediate';
import mergeWith from 'lodash.mergewith';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export function cloneArray(array, deep) {
    const arr = [];
    if (!array) {
        return arr;
    }
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 */
export function cloneHierarchicalArray(array, childDataKey) {
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
export function mergeObjects(obj1, obj2) {
    return mergeWith(obj1, obj2, (objValue, srcValue) => {
        if (Array.isArray(srcValue)) {
            return objValue = srcValue;
        }
    });
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
export function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
export function isDate(value) {
    return value instanceof Date;
}
/**
 * Parse provided input to Date.
 * @param value input to parse
 * @returns Date if parse succeed or null
 * @hidden
 */
export function parseDate(value) {
    // if value is Invalid Date return null
    if (isDate(value)) {
        return !isNaN(value.getTime()) ? value : null;
    }
    return value ? new Date(value) : null;
}
/**
 * Returns an array with unique dates only.
 * @param columnValues collection of date values (might be numbers or ISO 8601 strings)
 * @returns collection of unique dates.
 * @hidden
 */
export function uniqueDates(columnValues) {
    return columnValues.reduce((a, c) => {
        if (!a.cache[c.label]) {
            a.result.push(c);
        }
        a.cache[c.label] = true;
        return a;
    }, { result: [], cache: {} }).result;
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
export function getNodeSizeViaRange(range, node) {
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    const s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 */
export function isEdge() {
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 */
export function isFirefox() {
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
export class PlatformUtil {
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
}
PlatformUtil.ɵprov = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
PlatformUtil.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PlatformUtil.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/**
 * @hidden
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/** @hidden */
export function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 */
export function flatten(arr) {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
export const HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
export const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
export const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
export const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
export const ROW_ADD_KEYS = new Set(['+', 'add', '≠', '±', '=']);
export const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), ...Array.from(ROW_ADD_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);
export const HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l',
    /** This symbol corresponds to the Alt + L combination under MAC. */
    '¬']);
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
export function resizeObservable(target) {
    return new Observable((observer) => {
        const instance = new ResizeObserver((entries) => {
            observer.next(entries);
        });
        instance.observe(target);
        const unsubscribe = () => instance.disconnect();
        return unsubscribe;
    });
}
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
export function compareMaps(map1, map2) {
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    let match = true;
    const keys = Array.from(map2.keys());
    for (const key of keys) {
        if (map1.has(key)) {
            match = map1.get(key) === map2.get(key);
        }
        else {
            match = false;
        }
        if (!match) {
            break;
        }
    }
    return match;
}
/**
 *
 * Given a property access path in the format `x.y.z` resolves and returns
 * the value of the `z` property in the passed object.
 *
 * @hidden
 * @internal
 */
export function resolveNestedPath(obj, path) {
    var _a;
    const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
    let current = obj[parts.shift()];
    parts.forEach(prop => {
        if (current) {
            current = current[prop];
        }
    });
    return current;
}
/**
 *
 * Given a property access path in the format `x.y.z` and a value
 * this functions builds and returns an object following the access path.
 *
 * @example
 * ```typescript
 * console.log('x.y.z.', 42);
 * >> { x: { y: { z: 42 } } }
 * ```
 *
 * @hidden
 * @internal
 */
export function reverseMapper(path, value) {
    var _a;
    const obj = {};
    const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
    let _prop = parts.shift();
    let mapping;
    // Initial binding for first level bindings
    obj[_prop] = value;
    mapping = obj;
    parts.forEach(prop => {
        // Start building the hierarchy
        mapping[_prop] = {};
        // Go down a level
        mapping = mapping[_prop];
        // Bind the value and move the key
        mapping[prop] = value;
        _prop = prop;
    });
    return obj;
}
export function yieldingLoop(count, chunkSize, callback, done) {
    let i = 0;
    const chunk = () => {
        const end = Math.min(i + chunkSize, count);
        for (; i < end; ++i) {
            callback(i);
        }
        if (i < count) {
            setImmediate(chunk);
        }
        else {
            done();
        }
    };
    chunk();
}
export function mkenum(x) { return x; }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY29yZS91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsQyxPQUFPLGNBQWMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUMsT0FBTyxTQUFTLE1BQU0sa0JBQWtCLENBQUM7O0FBRXpDOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FBQyxLQUFZLEVBQUUsSUFBYztJQUNuRCxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7SUFDZixJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1IsT0FBTyxHQUFHLENBQUM7S0FDZDtJQUNELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDckIsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNSLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ25EO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEtBQVksRUFBRSxZQUFpQjtJQUNsRSxNQUFNLE1BQU0sR0FBVSxFQUFFLENBQUM7SUFDekIsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sTUFBTSxDQUFDO0tBQ2pC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Q0FBQztRQUNwQixrQkFBa0I7UUFDbEIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixrQ0FBa0M7UUFDbEMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUN0QixLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2pCLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDO0FBRUQsTUFBTSxVQUFVLFlBQVksQ0FBQyxLQUFhLEVBQUUsU0FBaUIsRUFBRSxRQUFpQyxFQUFFLElBQWdCO0lBQzlHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNWLE1BQU0sS0FBSyxHQUFHLEdBQUcsRUFBRTtRQUNmLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMzQyxPQUFPLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDakIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2Y7UUFDRCxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQUU7WUFDWCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdkI7YUFBTTtZQUNILElBQUksRUFBRSxDQUFDO1NBQ1Y7SUFDTCxDQUFDLENBQUM7SUFDRixLQUFLLEVBQUUsQ0FBQztBQUNaLENBQUM7QUFFRCxNQUFNLFVBQVUsTUFBTSxDQUFxRCxDQUFJLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCc7XG5pbXBvcnQgeyBzZXRJbW1lZGlhdGUgfSBmcm9tICcuL3NldEltbWVkaWF0ZSc7XG5pbXBvcnQgbWVyZ2VXaXRoIGZyb20gJ2xvZGFzaC5tZXJnZXdpdGgnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXk6IGFueVtdLCBkZWVwPzogYm9vbGVhbikge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBkZWVwID8gY2xvbmVWYWx1ZShhcnJheVtpXSkgOiBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lSGllcmFyY2hpY2FsQXJyYXkoYXJyYXk6IGFueVtdLCBjaGlsZERhdGFLZXk6IGFueSk6IGFueVtdIHtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtID0gY2xvbmVWYWx1ZShpdGVtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbVtjaGlsZERhdGFLZXldKSkge1xuICAgICAgICAgICAgY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldID0gY2xvbmVIaWVyYXJjaGljYWxBcnJheShjbG9uZWRJdGVtW2NoaWxkRGF0YUtleV0sIGNoaWxkRGF0YUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY2xvbmVkSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZXMgYWxsIGZpcnN0IGxldmVsIGtleXMgb2YgT2JqMiBhbmQgbWVyZ2VzIHRoZW0gdG8gT2JqMVxuICogQHBhcmFtIG9iajEgT2JqZWN0IHRvIG1lcmdlIGludG9cbiAqIEBwYXJhbSBvYmoyIE9iamVjdCB0byBtZXJnZSBmcm9tXG4gKiBAcmV0dXJucyBPYmoxIHdpdGggbWVyZ2VkIGNsb25lZCBrZXlzIGZyb20gT2JqMlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajE6IHt9LCBvYmoyOiB7fSk6IGFueSB7XG4gICAgcmV0dXJuIG1lcmdlV2l0aChvYmoxLCBvYmoyLCAob2JqVmFsdWUsIHNyY1ZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxufVxuXG4vKipcbiAqIENyZWF0ZXMgZGVlcCBjbG9uZSBvZiBwcm92aWRlZCB2YWx1ZS5cbiAqIFN1cHBvcnRzIHByaW1pdGl2ZSB2YWx1ZXMsIGRhdGVzIGFuZCBvYmplY3RzLlxuICogSWYgcGFzc2VkIHZhbHVlIGlzIGFycmF5IHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybnMgRGVlcCBjb3B5IG9mIHByb3ZpZGVkIHZhbHVlXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlOiBhbnkpOiBhbnkge1xuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi52YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZVZhbHVlKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgT2JqZWN0XG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgT2JqZWN0XG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufVxuXG4vKipcbiAqIFBhcnNlIHByb3ZpZGVkIGlucHV0IHRvIERhdGUuXG4gKiBAcGFyYW0gdmFsdWUgaW5wdXQgdG8gcGFyc2VcbiAqIEByZXR1cm5zIERhdGUgaWYgcGFyc2Ugc3VjY2VlZCBvciBudWxsXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGUodmFsdWU6IGFueSk6IERhdGUgfCBudWxsIHtcbiAgICAvLyBpZiB2YWx1ZSBpcyBJbnZhbGlkIERhdGUgcmV0dXJuIG51bGxcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkgPyB2YWx1ZSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHVuaXF1ZSBkYXRlcyBvbmx5LlxuICogQHBhcmFtIGNvbHVtblZhbHVlcyBjb2xsZWN0aW9uIG9mIGRhdGUgdmFsdWVzIChtaWdodCBiZSBudW1iZXJzIG9yIElTTyA4NjAxIHN0cmluZ3MpXG4gKiBAcmV0dXJucyBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBkYXRlcy5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZURhdGVzKGNvbHVtblZhbHVlczogYW55W10pIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWVzLnJlZHVjZSgoYSwgYykgPT4ge1xuICAgICAgICBpZiAoIWEuY2FjaGVbYy5sYWJlbF0pIHsgYS5yZXN1bHQucHVzaChjKTsgfVxuICAgICAgICBhLmNhY2hlW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfSwgeyByZXN1bHQ6IFtdLCBjYWNoZToge30gfSkucmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdHdvIHBhc3NlZCBhcmd1bWVudHMgYXJlIGVxdWFsXG4gKiBDdXJyZW50bHkgc3VwcG9ydHMgZGF0ZSBvYmplY3RzXG4gKiBAcGFyYW0gb2JqMVxuICogQHBhcmFtIG9iajJcbiAqIEByZXR1cm5zOiBgYm9vbGVhbmBcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMik6IGJvb2xlYW4ge1xuICAgIGlmIChpc0RhdGUob2JqMSkgJiYgaXNEYXRlKG9iajIpKSB7XG4gICAgICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZQ09ERVMge1xuICAgIEVOVEVSID0gMTMsXG4gICAgU1BBQ0UgPSAzMixcbiAgICBFU0NBUEUgPSAyNyxcbiAgICBMRUZUX0FSUk9XID0gMzcsXG4gICAgVVBfQVJST1cgPSAzOCxcbiAgICBSSUdIVF9BUlJPVyA9IDM5LFxuICAgIERPV05fQVJST1cgPSA0MCxcbiAgICBGMiA9IDExMyxcbiAgICBUQUIgPSA5LFxuICAgIENUUkwgPSAxNyxcbiAgICBaID0gOTAsXG4gICAgWSA9IDg5LFxuICAgIFggPSA4OCxcbiAgICBCQUNLU1BBQ0UgPSA4LFxuICAgIERFTEVURSA9IDQ2LFxuICAgIElOUFVUX01FVEhPRCA9IDIyOVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZUyB7XG4gICAgRU5URVIgPSAnRW50ZXInLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFNQQUNFX0lFID0gJ1NwYWNlYmFyJyxcbiAgICBFU0NBUEUgPSAnRXNjYXBlJyxcbiAgICBFU0NBUEVfSUUgPSAnRXNjJyxcbiAgICBMRUZUX0FSUk9XID0gJ0Fycm93TGVmdCcsXG4gICAgTEVGVF9BUlJPV19JRSA9ICdMZWZ0JyxcbiAgICBVUF9BUlJPVyA9ICdBcnJvd1VwJyxcbiAgICBVUF9BUlJPV19JRSA9ICdVcCcsXG4gICAgUklHSFRfQVJST1cgPSAnQXJyb3dSaWdodCcsXG4gICAgUklHSFRfQVJST1dfSUUgPSAnUmlnaHQnLFxuICAgIERPV05fQVJST1cgPSAnQXJyb3dEb3duJyxcbiAgICBET1dOX0FSUk9XX0lFID0gJ0Rvd24nLFxuICAgIEYyID0gJ0YyJyxcbiAgICBUQUIgPSAnVGFiJyxcbiAgICBTRU1JQ09MT04gPSAnOycsXG4gICAgSE9NRSA9ICdIb21lJyxcbiAgICBFTkQgPSAnRW5kJ1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIFJldHVybnMgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBub2RlIGNvbnRlbnQsIHVzaW5nIFJhbmdlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICpcbiAqIGxldCBzaXplID0gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlOiBSYW5nZSwgbm9kZTogYW55KTogbnVtYmVyIHtcbiAgICBsZXQgb3ZlcmZsb3cgPSBudWxsO1xuICAgIGlmICghaXNGaXJlZm94KCkpIHtcbiAgICAgICAgb3ZlcmZsb3cgPSBub2RlLnN0eWxlLm92ZXJmbG93O1xuICAgICAgICAvLyB3ZSBuZWVkIHRoYXQgaGFjayAtIG90aGVyd2lzZSBjb250ZW50IHdvbid0IGJlIG1lYXN1cmVkIGNvcnJlY3RseSBpbiBJRS9FZGdlXG4gICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgIGNvbnN0IHdpZHRoID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICBpZiAoIWlzRmlyZWZveCgpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQGhpZGRlblxuICogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgQ2FudmFzXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBsZXQgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAqXG4gKiBsZXQgc2l6ZSA9IHZhbFRvUHhsc1VzaW5nQ2FudmFzKGN0eCwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYUNhbnZhcyhjYW52YXMyZEN0eDogYW55LCBub2RlOiBhbnkpOiBudW1iZXIge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBmb250IHRvIGdldCBjb3JyZWN0IHdpZHRoXG4gICAgY2FudmFzMmRDdHguZm9udCA9IHMuZm9udFNpemUgKyAnICcgKyBzLmZvbnRGYW1pbHk7XG5cbiAgICByZXR1cm4gY2FudmFzMmRDdHgubWVhc3VyZVRleHQobm9kZS50ZXh0Q29udGVudCkud2lkdGg7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSUUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ1RyaWRlbnQvJykgPiAwO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VkZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZWRnZUJyb3dzZXIgPSAvRWRnZVtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gZWRnZUJyb3dzZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZpcmVmb3hCcm93c2VyID0gL0ZpcmVmb3hbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGZpcmVmb3hCcm93c2VyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBQbGF0Zm9ybVV0aWwge1xuICAgIHB1YmxpYyBpc0Jyb3dzZXI6IGJvb2xlYW4gPSBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpO1xuXG4gICAgcHVibGljIGlzSU9TID0gdGhpcy5pc0Jyb3dzZXIgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISgnTVNTdHJlYW0nIGluIHdpbmRvdyk7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCkge1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xlZnRDbGljayhldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05hdmlnYXRpb25LZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnZG93bicsXG4gICAgICAgICd1cCcsXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgJ2Fycm93ZG93bicsXG4gICAgICAgICdhcnJvd3VwJyxcbiAgICAgICAgJ2Fycm93bGVmdCcsXG4gICAgICAgICdhcnJvd3JpZ2h0JyxcbiAgICAgICAgJ2hvbWUnLFxuICAgICAgICAnZW5kJyxcbiAgICAgICAgJ3NwYWNlJyxcbiAgICAgICAgJ3NwYWNlYmFyJyxcbiAgICAgICAgJyAnXG4gICAgXS5pbmRleE9mKGtleSkgIT09IC0xO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyOiBhbnlbXSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgIGFyci5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgICBpZiAoZWwuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShlbC5jaGlsZHJlbikgPyBlbC5jaGlsZHJlbiA6IGVsLmNoaWxkcmVuLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdHRlbihjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgYWJpbGl0eSB0byBjYW5jZWwgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgcmVmZXJlbmNlIHRvIHRoZSBvd25lciBjb21wb25lbnQuXG4gICAgICovXG4gICAgb3duZXI/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKiogQnJvd3NlciBldmVudCAqL1xuICAgIGV2ZW50PzogRXZlbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUJhc2VDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyBleHRlbmRzIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzLCBJQmFzZUV2ZW50QXJncyB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBJQmFzZUNhbmNlbGFibGVFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlRXZlbnRBcmdzLCBJQmFzZUV2ZW50QXJncyB7IH1cblxuZXhwb3J0IGNvbnN0IEhPUklaT05UQUxfTkFWX0tFWVMgPSBuZXcgU2V0KFsnYXJyb3dsZWZ0JywgJ2xlZnQnLCAnYXJyb3dyaWdodCcsICdyaWdodCcsICdob21lJywgJ2VuZCddKTtcblxuZXhwb3J0IGNvbnN0IE5BVklHQVRJT05fS0VZUyA9IG5ldyBTZXQoW1xuICAgICdkb3duJyxcbiAgICAndXAnLFxuICAgICdsZWZ0JyxcbiAgICAncmlnaHQnLFxuICAgICdhcnJvd2Rvd24nLFxuICAgICdhcnJvd3VwJyxcbiAgICAnYXJyb3dsZWZ0JyxcbiAgICAnYXJyb3dyaWdodCcsXG4gICAgJ2hvbWUnLFxuICAgICdlbmQnLFxuICAgICdzcGFjZScsXG4gICAgJ3NwYWNlYmFyJyxcbiAgICAnICdcbl0pO1xuZXhwb3J0IGNvbnN0IFJPV19FWFBBTkRfS0VZUyA9IG5ldyBTZXQoJ3JpZ2h0IGRvd24gYXJyb3dyaWdodCBhcnJvd2Rvd24nLnNwbGl0KCcgJykpO1xuZXhwb3J0IGNvbnN0IFJPV19DT0xMQVBTRV9LRVlTID0gbmV3IFNldCgnbGVmdCB1cCBhcnJvd2xlZnQgYXJyb3d1cCcuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgUk9XX0FERF9LRVlTID0gbmV3IFNldChbJysnLCAnYWRkJywgJ+KJoCcsICfCsScsICc9J10pO1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9LRVlTID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShOQVZJR0FUSU9OX0tFWVMpLCAuLi5BcnJheS5mcm9tKFJPV19BRERfS0VZUyksICdlbnRlcicsICdmMicsICdlc2NhcGUnLCAnZXNjJywgJ3BhZ2Vkb3duJywgJ3BhZ2V1cCddKTtcbmV4cG9ydCBjb25zdCBIRUFERVJfS0VZUyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20oTkFWSUdBVElPTl9LRVlTKSwgJ2VzY2FwZScsICdlc2MnLCAnbCcsXG4gICAgLyoqIFRoaXMgc3ltYm9sIGNvcnJlc3BvbmRzIHRvIHRoZSBBbHQgKyBMIGNvbWJpbmF0aW9uIHVuZGVyIE1BQy4gKi9cbiAgICAnwqwnXSk7XG5cbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKlxuICogQ3JlYXRlcyBhIG5ldyBSZXNpemVPYnNlcnZlciBvbiBgdGFyZ2V0YCBhbmQgcmV0dXJucyBpdCBhcyBhbiBPYnNlcnZhYmxlLlxuICogUnVuIHRoZSByZXNpemVPYnNlcnZhYmxlIG91dHNpZGUgYW5ndWxhciB6b25lLCBiZWNhdXNlIGl0IHBhdGNoZXMgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgd2hpY2ggY2F1c2VzIGFuIGluZmluaXRlIGxvb3AuXG4gKiBSZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTcxMlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplT2JzZXJ2YWJsZSh0YXJnZXQ6IEhUTUxFbGVtZW50KTogT2JzZXJ2YWJsZTxSZXNpemVPYnNlcnZlckVudHJ5W10+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzOiBSZXNpemVPYnNlcnZlckVudHJ5W10pID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZW50cmllcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnN0YW5jZS5vYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4gaW5zdGFuY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKlxuICogQ29tcGFyZXMgdHdvIG1hcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlTWFwcyhtYXAxOiBNYXA8YW55LCBhbnk+LCBtYXAyOiBNYXA8YW55LCBhbnk+KTogYm9vbGVhbiB7XG4gICAgaWYgKCFtYXAyKSB7XG4gICAgICAgIHJldHVybiAhbWFwMSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG1hcDEuc2l6ZSAhPT0gbWFwMi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gdHJ1ZTtcbiAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShtYXAyLmtleXMoKSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAobWFwMS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBtYXAxLmdldChrZXkpID09PSBtYXAyLmdldChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qKlxuICpcbiAqIEdpdmVuIGEgcHJvcGVydHkgYWNjZXNzIHBhdGggaW4gdGhlIGZvcm1hdCBgeC55LnpgIHJlc29sdmVzIGFuZCByZXR1cm5zXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGB6YCBwcm9wZXJ0eSBpbiB0aGUgcGFzc2VkIG9iamVjdC5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVOZXN0ZWRQYXRoKG9iajogYW55LCBwYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhdGg/LnNwbGl0KCcuJykgPz8gW107XG4gICAgbGV0IGN1cnJlbnQgPSBvYmpbcGFydHMuc2hpZnQoKV07XG5cbiAgICBwYXJ0cy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjdXJyZW50O1xufVxuXG5cbi8qKlxuICpcbiAqIEdpdmVuIGEgcHJvcGVydHkgYWNjZXNzIHBhdGggaW4gdGhlIGZvcm1hdCBgeC55LnpgIGFuZCBhIHZhbHVlXG4gKiB0aGlzIGZ1bmN0aW9ucyBidWlsZHMgYW5kIHJldHVybnMgYW4gb2JqZWN0IGZvbGxvd2luZyB0aGUgYWNjZXNzIHBhdGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnNvbGUubG9nKCd4Lnkuei4nLCA0Mik7XG4gKiA+PiB7IHg6IHsgeTogeyB6OiA0MiB9IH0gfVxuICogYGBgXG4gKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlTWFwcGVyKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aD8uc3BsaXQoJy4nKSA/PyBbXTtcblxuICAgIGxldCBfcHJvcCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgbGV0IG1hcHBpbmc6IGFueTtcblxuICAgIC8vIEluaXRpYWwgYmluZGluZyBmb3IgZmlyc3QgbGV2ZWwgYmluZGluZ3NcbiAgICBvYmpbX3Byb3BdID0gdmFsdWU7XG4gICAgbWFwcGluZyA9IG9iajtcblxuICAgIHBhcnRzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIC8vIFN0YXJ0IGJ1aWxkaW5nIHRoZSBoaWVyYXJjaHlcbiAgICAgICAgbWFwcGluZ1tfcHJvcF0gPSB7fTtcbiAgICAgICAgLy8gR28gZG93biBhIGxldmVsXG4gICAgICAgIG1hcHBpbmcgPSBtYXBwaW5nW19wcm9wXTtcbiAgICAgICAgLy8gQmluZCB0aGUgdmFsdWUgYW5kIG1vdmUgdGhlIGtleVxuICAgICAgICBtYXBwaW5nW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIF9wcm9wID0gcHJvcDtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5aWVsZGluZ0xvb3AoY291bnQ6IG51bWJlciwgY2h1bmtTaXplOiBudW1iZXIsIGNhbGxiYWNrOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZCwgZG9uZTogKCkgPT4gdm9pZCkge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBjaHVuayA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oaSArIGNodW5rU2l6ZSwgY291bnQpO1xuICAgICAgICBmb3IgKDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoY2h1bmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjaHVuaygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWtlbnVtPFQgZXh0ZW5kcyB7IFtpbmRleDogc3RyaW5nXTogVSB9LCBVIGV4dGVuZHMgc3RyaW5nPih4OiBUKSB7IHJldHVybiB4OyB9XG4iXX0=